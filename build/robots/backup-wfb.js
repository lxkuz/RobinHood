// Generated by CoffeeScript 1.10.0
(function() {
  var BackupWFBRobot, BaseRobot, _,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BaseRobot = require('./base');

  _ = require('underscore');

  BackupWFBRobot = (function(superClass) {
    extend(BackupWFBRobot, superClass);

    function BackupWFBRobot(options) {
      this.getCoverValue = bind(this.getCoverValue, this);
      this.tryToCover = bind(this.tryToCover, this);
      this.playAlgorithm = bind(this.playAlgorithm, this);
      BackupWFBRobot.__super__.constructor.apply(this, arguments);
      this.G = options.G;
    }

    BackupWFBRobot.prototype.playAlgorithm = function(data) {
      var type;
      if (this.betsData.length === 1) {
        this.tryToCover(data);
      }
      if (this.betsData.length === 0) {
        type = Math.random() >= 0.5 ? 'p1' : 'p2';
        return this.makeBet(50, type, data[type]);
      }
    };

    BackupWFBRobot.prototype.tryToCover = function(data) {
      var prevBet, value;
      prevBet = this.betsData[this.betsData.length - 1];
      if (prevBet.type === 'p1') {
        value = this.getCoverValue(prevBet, data.p2);
        if (value) {
          return this.makeBet(value, 'p2', data.p2);
        }
      } else {
        value = this.getCoverValue(prevBet, data.p1);
        if (value) {
          return this.makeBet(value, 'p1', data.p1);
        }
      }
    };

    BackupWFBRobot.prototype.getCoverValue = function(prevBet, nextKoef) {
      var bet, costs, minProfit, variants;
      variants = [];
      bet = 0;
      minProfit = 0;
      costs = prevBet.value;
      while (bet <= this.money) {
        if (minProfit / costs >= 1) {
          variants.push({
            bet: bet,
            G: minProfit / costs
          });
        }
        bet += 10;
        costs = prevBet.value + bet;
        minProfit = Math.min(prevBet.value * prevBet.k, nextKoef * bet);
      }
      if (variants.length === 0) {
        return 0;
      }
      return _.sortBy(variants, function(obj) {
        return obj.G;
      })[0].bet;
    };

    return BackupWFBRobot;

  })(BaseRobot);

  module.exports = BackupWFBRobot;

}).call(this);
